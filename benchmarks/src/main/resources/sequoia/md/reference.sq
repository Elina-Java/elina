/*******************************************************************************
 * Copyright (c) 2010,
 *   The Board of Trustees of The Leland Stanford Junior University
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 * 
 * 3. The names of the contributors may not be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************/

#include "reference.h"

#include "../../external/include/sq_cmath.h"

#include "constants.h"

void accelRef(Float3* pos, Float3* forces, float* mass, int n)
{
	for( unsigned int i = 0; i < n; i++ )
		forces[i].x = forces[i].y = forces[i].z = 0.0;

	for( unsigned int i = 0; i < n; i++ )
		for( unsigned int j = i + 1; j < n; j++ )
		{
			Float3 r;
			r.x = pos[i].x - pos[j].x;
			r.y = pos[i].y - pos[j].y;
			r.z = pos[i].z - pos[j].z;
			
			float rinv = 1.0 / sq_sqrt(r.x*r.x + r.y*r.y + r.z*r.z + EPS);
			float rinv3 = rinv * rinv * rinv;

			forces[i].x -= mass[j] * rinv3 * r.x;
			forces[i].y -= mass[j] * rinv3 * r.y;
			forces[i].z -= mass[j] * rinv3 * r.z;
			
			forces[j].x += mass[i] * rinv3 * r.x;
			forces[j].y += mass[i] * rinv3 * r.y;
			forces[j].z += mass[i] * rinv3 * r.z;
		}
}

void posUpdateRef(Float3* pos, Float3* vel, Float3* forces, int n) 
{
	for ( unsigned int i = 0; i < n; i++ ) 
	{
		pos[i].x += DELTA_T * (vel[i].x + 0.5 * DELTA_T * forces[i].x);
		pos[i].y += DELTA_T * (vel[i].y + 0.5 * DELTA_T * forces[i].y);
		pos[i].z += DELTA_T * (vel[i].z + 0.5 * DELTA_T * forces[i].z);
	}
}

void velUpdateRef(Float3* vel, Float3* accel, Float3* accelOld, int n) 
{
	for ( unsigned int i  = 0; i < n; i++ ) 
	{
		vel[i].x += 0.5 * DELTA_T * ( accel[i].x + accelOld[i].x );
		vel[i].y += 0.5 * DELTA_T * ( accel[i].y + accelOld[i].y );
		vel[i].z += 0.5 * DELTA_T * ( accel[i].z + accelOld[i].z );
	}		
}

void mdRef(Float3* pos, Float3* vel, float* mass, int n, int nSteps)
{
	Float3* accelOld = new Float3[n];
	Float3* accelCur = new Float3[n];

	accelRef(pos, accelCur, mass, n);

	for( unsigned int t = 0; t < nSteps; t++ )
	{
		posUpdateRef(pos, vel, accelCur, n);
		for( unsigned int i = 0; i < n; i++ )
		{
			accelOld[i].x = accelCur[i].x;
			accelOld[i].y = accelCur[i].y;
			accelOld[i].z = accelCur[i].z;
		}

		accelRef(pos, accelCur, mass, n);
		velUpdateRef(vel, accelCur, accelOld, n);
	}

	delete [] accelOld;
	delete [] accelCur;
}

